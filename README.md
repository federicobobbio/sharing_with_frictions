# Sharing with Frictions: Limited Transfers and Costly Inspections <!-- omit from toc -->

This repository is distributed under the [MIT License](LICENSE).

This archive contains the Python code used to generate the figures in the paper:

**Sharing with Frictions: Limited Transfers and Costly Inspections**  

by Federico Bobbio, Randall Berry, Michael Honig, Thanh Nguyen, Vijay Subramanian, Rakesh Vohra.


## Table of Contents <!-- omit from toc -->

- [Description](#description)
- [Python scripts](#python-scripts)
  - [Package installation](#package-installation)
  - [Solving tools and Results](#solving-tools-and-results)


## Description 
The code implements numerical simulations and optimization models under different interference settings (e.g., independent and power), relying on Gurobi to solve linear programs and using Python libraries to visualize results. The Python environment consists of scripts organized into the following structure:

project-root/
├── scripts/
│   └── RunScript.py              # Main script to generate all plots
│
├── src/
│   ├── fig_1_2.py                # Code for Figures 1 and 2
│   ├── fig_3_4.py                # Code for Figures 3 and 4
│   ├── fig_5_6.py                # Code for Figures 5 and 6
│   ├── fig_7_8.py                # Code for Figures 7 and 8
│   └── models.py                 # Shared model-building and solving functions
│
├── results/
│   └── plots/
│       ├── indep/                # Saved plots under independent interference
│       └── power/                # Saved plots under power interference
│
├── requirements.txt              # Python dependencies
├── LICENSE                       # License information
└── README.md                     # Project documentation


Our results were obtained on an Apple M3 Pro CPU and 36 GB of RAM, using Gurobi 13.0.0 to solve optimization problems with code written in Python 3.13.3. The total time to run all instances and methods was approximately 1 hour.
All figures in the main text (Figures 1 through 8) can be generated by running:
python scripts/RunScript.py
You can uncomment lines in RunScript.py to select which figures to produce. Each script uses a common dictionary of parameters (default_pars) which can be easily modified for experimentation.


## Python scripts

The src directory contains five Python scripts: one (models.py) defines the core model and generates output data, while the others are used to visualize results and reproduce the figures from the paper.

The file scripts/RunScript.py is the main driver script of the Python code. It imports all figure‑generation routines from the src directory and reproduces every figure in the paper using a shared set of parameters.


### Installation

To run these Python scripts, you will need Python 3.13.3 installed on your system.

Furthermore, the Python scripts require the following packages:

    numpy
    matplotlib
    gurobipy
    scipy
    cycler


which can be installed by running the command: 

```python
pip install numpy matplotlib gurobipy scipy cycler 
```

We also created a requirements.txt that can be installed to create the environment with the required packages by running the following command:

```python
pip install -r requirements.txt
```

### Solving tools and Results

The RunScript.py script serves as the main entry point to reproduce all figures in the paper. It imports functions from the individual Python files in src/ and calls them with predefined parameters. To generate the plots, simply run:

```python
python python RunScript.py
```

The plots will be saved in the directory results/plots/{power, indep}, depending on the chosen interference type. 

**Remark:** You may modify the default parameters in RunScript.py to explore alternative settings or reproduce variations of the figures. The defaults are defined in the default_pars dictionary and can be changed as needed. Each figure-generating function accepts a params dictionary, so you can override values selectively. Below is a description of each parameter:


| Parameter   | Description                                                                                     |
| ----------- | ----------------------------------------------------------------------------------------------- |
| `n_u`       | Number of discretization points for the resource level ( u ); controls horizontal resolution.   |
| `n_alpha`   | Number of discretization points for the ability level ( \alpha ); controls vertical resolution. |
| `u_bar`     | Upper bound for ( u ); domain is ([0, u_{\text{bar}}]).                                         |
| `alpha_bar` | Upper bound for ( \alpha ); domain is ([0, \alpha_{\text{bar}}]).                               |
| `K`         | Cost of inspection. Can be varied to study how the mechanism adapts to inspection frictions.    |
| `v`         | Value of the object being shared. Influences inspection incentives and allocations.             |
| `f_type`    | Distribution type for ( f(\alpha) ) (e.g., `"gaussian"`, `"uniform"`).                          |
| `f_mu`      | Mean of ( f(\alpha) ), if Gaussian.                                                             |
| `f_sigma`   | Standard deviation of ( f(\alpha) ), if Gaussian.                                               |
| `g_type`    | Distribution type for ( g(u) ) (e.g., `"gaussian"`, `"uniform"`).                               |
| `g_mu`      | Mean of ( g(u) ), if Gaussian.                                                                  |
| `g_sigma`   | Standard deviation of ( g(u) ), if Gaussian.                                                    |


